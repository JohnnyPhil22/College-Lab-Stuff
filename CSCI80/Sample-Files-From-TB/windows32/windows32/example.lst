Microsoft (R) Macro Assembler Version 14.44.35219.0	    11/03/25 21:45:51
example.asm						     Page 1 - 1


				.586
				.MODEL FLAT

				INCLUDE io.h            ; header file for input/output
			      C ; IO.H -- header file for I/O macros (listing suppressed)
			      C .NOLIST      ; turn off listing
			      C .LIST        ; begin listing
			      C 

				.STACK 4096

 00000000			.DATA
 00000000 00000000		number1     DWORD   ?
 00000004 00000000		number2     DWORD   ?
 00000008 45 6E 74 65 72	prompt1     BYTE    "Enter first number", 0
	   20 66 69 72 73
	   74 20 6E 75 6D
	   62 65 72 00
 0000001B 45 6E 74 65 72	prompt2     BYTE    "Enter second number", 0
	   20 73 65 63 6F
	   6E 64 20 6E 75
	   6D 62 65 72 00
 0000002F  00000028 [		string      BYTE    40 DUP (?)
	    00
	   ]
 00000057 54 68 65 20 73	resultLbl   BYTE  "The sum is", 0
	   75 6D 20 69 73
	   00
 00000062  0000000B [		sum         BYTE    11 DUP (?), 0
	    00
	   ] 00
 0000006E 00000001		arr1        DWORD   1, 3, 5, 7, 9, 11
	   00000003
	   00000005
	   00000007
	   00000009
	   0000000B

 00000000			.CODE
 00000000			myPow PROC      ; Save x^y to EAX
 00000000  55			    push EBP        ; ENTRY CODE
 00000001  8B EC		    mov EBP, ESP

 00000003  8B 5D 08		    mov EBX, DWORD PTR [EBP + 8]        ; get exponent y
 00000006  8B 4D 0C		    mov ECX, DWORD PTR [EBP + 12]       ; get base x

 00000009  B8 00000001		    mov EAX, 1      ; initialize result to 1
 0000000E			    LBEGIN:
 0000000E  F7 E3		        mul EBX     ; EAX = EAX * x
 00000010  E2 FC		        loop LBEGIN

 00000012  5D			    pop EBP     ; EXIT CODE
 00000013  C3			    ret
 00000014			myPow ENDP

 00000014			Comp2 PROC     ; Compare two numbers
 00000014  55			    push EBP        ; ENTRY CODE
 00000015  8B EC		    mov EBP, ESP

 00000017  8B 5D 08		    mov EBX, DWORD PTR [EBP + 8]        ; get number a
 0000001A  8B 4D 0C		    mov ECX, DWORD PTR [EBP + 12]       ; get number b

 0000001D  3B D9		    cmp EBX, ECX
 0000001F  74 10		    je  EQUAL
 00000021  7C 07		    jl  LESS
 00000023  B8 00000001		    mov EAX, 1      ; a > b
 00000028  EB 0C		    jmp DONE
 0000002A			    LESS:
 0000002A  B8 FFFFFFFF		        mov EAX, -1     ; a < b
 0000002F  EB 05		        jmp DONE
 00000031			    EQUAL:
 00000031  B8 00000000		        mov EAX, 0      ; a == b
 00000036			    DONE:
 00000036  5D			        pop EBP     ; EXIT CODE
 00000037  C3			        ret
 00000038			Comp2 ENDP

 00000038			Comp3 PROC     ; Compare three numbers
 00000038  55			    push EBP        ; ENTRY CODE
 00000039  8B EC		    mov EBP, ESP

 0000003B  66| 8B 45 08		    mov AX, [EBP + 8]         ; get number a
 0000003F  66| 8B 5D 0A		    mov BX, [EBP + 10]        ; get number b
 00000043  66| 8B 4D 0C		    mov CX, [EBP + 12]        ; get number c

 00000047  66| 3B C3		    cmp AX, BX
 0000004A  7D 03		    jge Chk_AC
 0000004C  66| 8B C3		    mov AX, BX

 0000004F			    Chk_AC:
 0000004F  66| 3B C1		    cmp AX, CX
 00000052  7D 03		    jge A_Max
 00000054  66| 8B C1		    mov AX, CX
				    
 00000057			    A_Max:
 00000057  5D			        pop EBP         ; EXIT CODE
 00000058  C3			        ret
 00000059			Comp3 ENDP

 00000059			factNum PROC    ; Calculate factorial of n
 00000059  55			    push EBP        ; ENTRY CODE
 0000005A  8B EC		    mov EBP, ESP

 0000005C  83 7D 08 01		    cmp DWORD PTR [EBP + 8], 1
 00000060  7F 07		    jg RECURSE
 00000062  B8 00000001		    mov EAX, 1
 00000067  EB 10		    jmp EXIT

 00000069			    RECURSE:
 00000069  8B 5D 08		        mov EBX, DWORD PTR [EBP + 8]
 0000006C  4B			        dec EBX
 0000006D  53			        push EBX
 0000006E  E8 FFFFFFE6		        call factNum
 00000073  83 C4 04		        add ESP, 4
 00000076  43			        inc EBX
 00000077  F7 E3		        mul EBX

 00000079			    EXIT:
 00000079  5D			        pop EBP         ; EXIT CODE
 0000007A  C3			        ret
 0000007B			factNum ENDP

 0000007B			myAvg PROC      ; Calculate average of array of numbers
 0000007B  55			    push EBP        ; ENTRY CODE
 0000007C  8B EC		    mov EBP, ESP

 0000007E  53			    push EBX
 0000007F  51			    push ECX

 00000080  8B 5D 08		    mov EBX, DWORD PTR [EBP + 8]        ; get first number
 00000083  8B 4D 0C		    mov ECX, DWORD PTR [EBP + 12]       ; get second number
 00000086  B8 00000000		    mov EAX, 0      ; initialize sum to 0
 0000008B  49			    dec ECX

 0000008C			    Begin_Avg_Calc:
 0000008C  03 44 0B 04		        add EAX, DWORD PTR[EBX+4+ECX] ; add array element to sum
 00000090  49			        dec ECX
 00000091  83 F9 00		        cmp ECX, 0
 00000094  7C 02		        jl Done
 00000096  EB F4		        jmp Begin_Avg_Calc

 00000098			    Done:
 00000098  99			        cdq			 ; extend EAX to EDX:EAX for division
 00000099  F7 75 0C		        div DWORD PTR [EBP + 12]      ; divide sum by count
				    
 0000009C  59			    pop ECX
 0000009D  5B			    pop EBX
 0000009E  5D			    pop EBP     ; EXIT CODE
 0000009F  C3			    ret
 000000A0			myAvg ENDP

				add3    MACRO p1, p2, p3        ; Macro to add three numbers and store in p1
				        push EDX
				        mov EDX, p1
				        add EDX, p2
				        add EDX, p3
				        mov p1, EDX
				        ENDM

 000000A0			myPerm PROC         ; Calculate permutation nPr, two DWORD params
 000000A0  55			    push EBP        ; ENTRY CODE
 000000A1  8B EC		    mov EBP, ESP

 000000A3  53			    push EBX

 000000A4  8B 5D 08		    mov EBX, DWORD PTR [EBP + 8]        ; get n
 000000A7  8B 4D 0C		    mov ECX, DWORD PTR [EBP + 12]       ; get r
 000000AA  B8 00000001		    mov EAX, 1          ; init result = 1
				    
 000000AF  E3 0D		    jecxz End_Loop     ; if r == 0, skip loop

 000000B1  3B CB		    cmp ECX, EBX
 000000B3  7F 07		    jg R_Greater_N        ; if r > n, skip loop

 000000B5			    Perm_Loop:
 000000B5  F7 E3		        mul EBX         ; result *= n
 000000B7  4B			        dec EBX         ; n--
 000000B8  E2 FB		        loop Perm_Loop
 000000BA  EB 02		        jmp End_Loop

 000000BC			    R_Greater_N:
 000000BC  33 C0		        xor EAX, EAX    ; result = 0

 000000BE			    End_Loop:
 000000BE  5B			        pop EBX
 000000BF  5D			        pop EBP     ; EXIT CODE
 000000C0  C3			        ret
 000000C1			myPerm ENDP

 000000C1			_MainProc PROC
				    ; Example code for adding two numbers from user input (TB material)
				    input   prompt1, string, 40      ; read ASCII characters
				    atod    string          ; convert to integer
 000000EE  A3 00000000 R	    mov     number1, EAX    ; store in memory

				    input   prompt2, string, 40      ; repeat for second number
				    atod    string
 00000120  A3 00000004 R	    mov     number2, EAX
				        
 00000125  A1 00000000 R	    mov     EAX, number1    ; first number to EAX
 0000012A  03 05 00000004 R	    add     EAX, number2    ; add second number
				    dtoa    sum, EAX        ; convert to ASCII characters
				    output  resultLbl, sum          ; output label and sum

				    ; Example code for x^y proc
 00000161  6A 03		    pushd 3         ; exponent
 00000163  6A 02		    pushd 2         ; base
 00000165  E8 FFFFFE96		    call myPow
 0000016A  83 C4 08		    add ESP, 8

				    ; Example code for comparing three numbers proc
 0000016D  66| 6A 03		    pushw 3         ; third number 
 00000170  66| 6A 02		    pushw 2         ; second number
 00000173  66| 6A 01		    pushw 1         ; first number
 00000176  E8 FFFFFEBD		    call Comp3
 0000017B  83 C4 06		    add ESP, 6

				    ; Example code for factorial proc
 0000017E  6A 03		    pushd 3         ; number to factorial
 00000180  E8 FFFFFED4		    call factNum
 00000185  83 C4 04		    add ESP, 4

				    ; Example code for average of array proc
 00000188  6A 06		    pushd 6         ; number of elements
 0000018A  8D 0D 0000006E R	    lea ECX, arr1   ; address of array
 00000190  51			    push ECX        ; array address
 00000191  E8 FFFFFEE5		    call myAvg
 00000196  83 C4 08		    add ESP, 8

				    ; Example usage of add3 macro
				    add3    EAX, number1, 6

				    ; Example usage of permutation proc
 000001A7  6A 02		    pushd 2         ; r
 000001A9  6A 06		    pushd 6         ; n
 000001AB  E8 FFFFFEF0		    call myPerm
 000001B0  83 C4 08		    add ESP, 8

 000001B3  B8 00000000		    mov     EAX, 0      ; exit with return code 0
 000001B8  C3			    ret
 000001B9			_MainProc ENDP
				END                             ; end of source code
Microsoft (R) Macro Assembler Version 14.44.35219.0	    11/03/25 21:45:51
example.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

add3 . . . . . . . . . . . . . .	Proc
atod . . . . . . . . . . . . . .	Proc
atow . . . . . . . . . . . . . .	Proc
dtoa . . . . . . . . . . . . . .	Proc
input  . . . . . . . . . . . . .	Proc
output . . . . . . . . . . . . .	Proc
wtoa . . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000086 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000001B9 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

Comp2  . . . . . . . . . . . . .	P Near	 00000014 _TEXT	Length= 00000024 Public
  LESS . . . . . . . . . . . . .	L Near	 0000002A _TEXT	
  EQUAL  . . . . . . . . . . . .	L Near	 00000031 _TEXT	
  DONE . . . . . . . . . . . . .	L Near	 00000036 _TEXT	
Comp3  . . . . . . . . . . . . .	P Near	 00000038 _TEXT	Length= 00000021 Public
  Chk_AC . . . . . . . . . . . .	L Near	 0000004F _TEXT	
  A_Max  . . . . . . . . . . . .	L Near	 00000057 _TEXT	
_MainProc  . . . . . . . . . . .	P Near	 000000C1 _TEXT	Length= 000000F8 Public
factNum  . . . . . . . . . . . .	P Near	 00000059 _TEXT	Length= 00000022 Public
  RECURSE  . . . . . . . . . . .	L Near	 00000069 _TEXT	
  EXIT . . . . . . . . . . . . .	L Near	 00000079 _TEXT	
myAvg  . . . . . . . . . . . . .	P Near	 0000007B _TEXT	Length= 00000025 Public
  Begin_Avg_Calc . . . . . . . .	L Near	 0000008C _TEXT	
  Done . . . . . . . . . . . . .	L Near	 00000098 _TEXT	
myPerm . . . . . . . . . . . . .	P Near	 000000A0 _TEXT	Length= 00000021 Public
  Perm_Loop  . . . . . . . . . .	L Near	 000000B5 _TEXT	
  R_Greater_N  . . . . . . . . .	L Near	 000000BC _TEXT	
  End_Loop . . . . . . . . . . .	L Near	 000000BE _TEXT	
myPow  . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000014 Public
  LBEGIN . . . . . . . . . . . .	L Near	 0000000E _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_getInput  . . . . . . . . . . .	L Near	 00000000 FLAT	External
_showOutput  . . . . . . . . . .	L Near	 00000000 FLAT	External
arr1 . . . . . . . . . . . . . .	DWord	 0000006E _DATA	
atodproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
atowproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
dtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
number1  . . . . . . . . . . . .	DWord	 00000000 _DATA	
number2  . . . . . . . . . . . .	DWord	 00000004 _DATA	
prompt1  . . . . . . . . . . . .	Byte	 00000008 _DATA	
prompt2  . . . . . . . . . . . .	Byte	 0000001B _DATA	
resultLbl  . . . . . . . . . . .	Byte	 00000057 _DATA	
string . . . . . . . . . . . . .	Byte	 0000002F _DATA	
sum  . . . . . . . . . . . . . .	Byte	 00000062 _DATA	
wtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External

	   0 Warnings
	   0 Errors
